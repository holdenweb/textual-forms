## textual_forms

This is the very beginning of a forms package for textual, (very) loosely
based on the Django forms framework, although currently with far fewer
refinements and lots of omissions. The intention is to provide a declarative
framework for data entry and editing that is usable and useful enough to have
people extend it rather than craft their own.

This document is intended to facilitate and guide design discussions
on the textual Discord server.

If this project is left to me it will die, because I already know I have
neither the time nor the energy to support such an effort alone. Some
interest has, however, already been expressed by various community members
and so my hope is that it will inspire the textual community to help with
discussions on Discord, suggestions, issues and most valuable of all, pull
requests.

As of this 0.2.2 release, control of development uses the _uv_ utility,
which among other things makes running the demo much simpler. The command

    uvx --from git+https://github.com/holdenweb/textual-forms.git forms-app

should display a screen that looks something like this.

![Screenshot of forms.py in action](images/screenshot.gif "forms.py demo")

### Architecture

Note that by no means all aspects of the architecture are yet implemented, and there
is rather more to do than described here to turn this into something that
people will want to use. Hence the need for help.

The Form class is the basis of forms development; Forms contain one or more
Fields, each of which is associated with a Widget instance, which may be of
the Field's default type or passed as an argument to the Field instance.

When a form is created it optionally takes a `data` and a `files` mapping,
either or both of which may initially be empty. The fields whose names
appear as keys in the mapping are populated with the associated value.

Field values are validated whenever their widgets lose focus (i.e. a Blur event is
raised). Each field has an `_errors` private attribute that is initially set
to None, and after validation contains a list of any ValidationError
instances generated by validation. The `errors` property, when accessed,
runs validation if `\_errors` is None (otherwise the field value
has already been validated), and if the \_errors list is then non-empty
each validation message is displayed underneath the field.

The programmer creates a Form subclass, and within it binds a number of
Field instances to class variables. The form's render method returns a
Vertical in which each of the fields' widgets in turn is rendered,
followed by one or more buttons in a row
(usually Cancel and Submit, but there should be an API to allow
modifications).

Setting a field's value inside the program propagates the change to the
widget's display. The fields value can also be modified through the TUI.
After any programmatic change the field's validators will be called,
potentially raising ValidationErrors, the first of which should
propagate to the client attempting to make the change.

Because some widgets can be compound (e.g. day, month, year in a date picker)
the widget accepts values as a dict, and returns them the same way. By
convention a simple widget uses the `value` key for its value item.

When a Form's `render` method is called all fields in the `data` and `files` dicts are set to the given
values; fields not included in the data are set to their default values, if
specified. If any fields are left without a value when one or both of the
dictionaries are passed a ValueError exception is raised.
Otherwise the form components are mounted and become available for user
interaction.

Clicking the form's Submit button triggers its `full_clean` method.
This clears the form's `_errors` and `cleaned_data` dictionaries, then
calls its `_clean_fields`, `_clean_form()` and `_post_clean()` methods.

`_clean_fields` iterates over the fields, extracting the values from
the widgets and validating them. Any ValidationErrors arising
(a field can have multiple validators) are stored
in the form's `_errors` dictionary under the field name, and the `clean` method
should return `None`; generic form errors are stored against a key of `None`.

`_post_clean` is typically used when a form is being used to maintain a specific
data model, to validate the data's suitability to populate a model instance once
data validation has taken place. \[Is this a YAGNI?\]

`_clean_form` method calls the form's `clean` method (null by default,
but overridable by subclasses), which will either raise a ValidationError
(which is stored in the form's `_errors` dict under a `None` key) or
return the form's `cleaned_data` dict.

The form's `errors` property, when accessed, checks the form's `_errors`
attribute, and if its value is `None` it calls the `full_clean` method. It
then returns the form's `_errors` dict, which is empty if no errors were
detected.

When no errors are detected a FormSubmitted event is raised with the
validated form data available as an attribute of the event. If the form is
cancelled a FormCancelled event is raised.

### Specific refactorings

This package is currently vestigial, with the barest proof-of-concept
demonstrating a fragile ability to turn Form subclasses into displayable
textual objects. The existing "framework" needs to be elaborated to improve
and formalise the Form-Field and the Field-Widget interfaces.

Many concepts from the Django forms package are proving to be of
assistance here, since it has already solved many of the domain's problems.
The different nature of its client/server interaction model, however, enforces a
somewhat cumbersome interface which we do not need to suffer in the Textual
environment. This simplifies more sophisticated interactions such as
changing the list of available values in a Select widget in response to
a change in a particular option.

Astute readers will notice there is absolutely no styling on the form
components. As a result the proof-of-concept form looks pretty ropey in a
window of non-optimal size.

## textual_forms

This is the modest beginning of a forms package for textual.
The intention is to provide a declarative
framework for data entry and editing that is usable and useful enough to have
people extend it rather than craft their own.

If you have `uv` installed you can run the demo program without cloning
the repository with the `uvx` command

    uvx --from git+https://github.com/holdenweb/textual-forms.git forms-app

This should produce a window that looks something like this:

![Screenshot of forms.py in action](images/screenshot.gif "textual_forms demo")

The inputs are validated on any change, and validation problems are reported
underneath the field in question.

![Screenshot of validation messages](images/validation.gif "textual_forms validation")

When you submit the form, the demo program displays the values you've entered as a
dictionary, keyed by the field names.

![Screenshot of forms result](images/results.gif "textual_forms validation")

Below is the source for the form from the demo program, which
contains one of each of the currently-supported field types.

``` python
class MyForm(Form):
    name = TextField(
        placeholder="Name (palindrome)",
        required=True,
        validators=[Palindromic()],
        id="form-name",
    )
    age = IntegerField(
        placeholder="Age (must be even)",
        required=False,
        validators=[Number(minimum=0, maximum=130), EvenInteger()],
        id="form-age",
    )

    is_active = BooleanField(label="Active?", id="form-isactive")

    choice = ChoiceField(
        prompt="Select pill colo(u)r",
        choices=[("blue", "Option 1"), ("red", "Option 2")],
        label="Selection",
        id="form-choice",
    )
```

### Testing

A Makefile exists with various targets to assist developers.
`make test` runs pytest, reporting each test on its own line.
`make coverage` runs pytest and reports on current test suite coverage.

`make release` prints the latest release number.
`make release version=X.Y.Z` creates a new release tagged as `rX.Y.Z` locally.
Still missing is a `publish` target that will push the latest release,
and the new tag, to GitHub before publishing it on PyPi.

## Contribute!!

If this project is left to me it will die, because I already know I have
neither the time nor the energy to support such an effort alone. Some
interest has, however, already been expressed by various community members
and so my hope is that this initial stimulus will inspire the `textual` community to help with
discussions on Discord, suggestions, issues - indeed, any kind of engagement.
Pull requests are always most valuable, but at this stage discussions,
suggestions and issues are just as necessary!

The remainder of this document is intended to facilitate and guide design
discussions on the textual Discord server. I have already identified a number
of high-priority issues which are [logged in the
repository](https://github.com/holdenweb/textual-forms/issues).
Some of the notes are outdated and do not necessarily reflect current thinking - for
example, a FileField could (except for textual web) simply provide a path to
local filestore.

Differences between the desktop and textual-web environments will need careful consideration.
Note that by no means all aspects of the architecture described here are yet implemented,
and there is rather more to do than currently listed to turn this into
a library that people will want to use. Hence the need for help.


### Architecture

The Form class is the basis of forms development; Forms contain one or more
Fields, each of which is associated with a Widget instance, which may be of
the Field's default type or passed as an argument to the Field instance.

When a form is created it optionally takes a `data` and a `files` mapping,
either or both of which may initially be empty. The fields whose names
appear as keys in the mapping are populated with the associated value.

Field values are validated whenever their widgets lose focus (i.e. a Blur event is
raised). Each field has an `_errors` private attribute that is initially set
to None, and after validation contains a list of any ValidationError
instances generated by validation. The `errors` property, when accessed,
runs validation if `\_errors` is None (otherwise the field value
has already been validated), and if the \_errors list is then non-empty
each validation message is displayed underneath the field.

The programmer creates a Form subclass, and within it binds a number of
Field instances to class variables. The form's render method returns a
Vertical in which each of the fields' widgets in turn is rendered,
followed by one or more buttons in a row
(usually Cancel and Submit, but there should be an API to allow
modifications).

Setting a field's value inside the program propagates the change to the
widget's display. The fields value can also be modified through the TUI.
After any programmatic change the field's validators will be called,
potentially raising ValidationErrors, the first of which should
propagate to the client attempting to make the change.

Because some widgets can be compound (e.g. day, month, year in a date picker)
the widget accepts values as a dict, and returns them the same way. By
convention a simple widget uses the `value` key for its value item.

When a Form's `render` method is called all fields in the `data`
and `files` dicts are set to the given
values; fields not included in the data are set to their default values, if
specified. If any fields are left without a value when one or both of the
dictionaries are passed a ValueError exception is raised.
Otherwise the form components are mounted and become available for user
interaction.

Clicking the form's Submit button triggers its `full_clean` method.
This clears the form's `_errors` and `cleaned_data` dictionaries, then
calls its `_clean_fields`, `_clean_form()` and `_post_clean()` methods.

`_clean_fields` iterates over the fields, extracting the values from
the widgets and validating them. Any ValidationErrors arising
(a field can have multiple validators) are stored
in the form's `_errors` dictionary under the field name, and the `clean` method
should return `None`; generic form errors are stored against a key of `None`.

`_post_clean` is typically used when a form is being used to maintain a specific
data model, to validate the data's suitability to populate a model instance once
data validation has taken place. \[Is this a YAGNI?\]

`_clean_form` method calls the form's `clean` method (null by default,
but overridable by subclasses), which will either raise a ValidationError
(which is stored in the form's `_errors` dict under a `None` key) or
return the form's `cleaned_data` dict.

The form's `errors` property, when accessed, checks the form's `_errors`
attribute, and if its value is `None` it calls the `full_clean` method. It
then returns the form's `_errors` dict, which is empty if no errors were
detected.

When no errors are detected a FormSubmitted event is raised with the
validated form data available as an attribute of the event. If the form is
cancelled a FormCancelled event is raised.

### Specific refactorings

This package is currently vestigial, with the barest proof-of-concept
demonstrating a fragile ability to turn Form subclasses into displayable
textual objects. The existing "framework" needs to be elaborated to improve
and formalise the Form-Field and the Field-Widget interfaces.

Many concepts from the Django forms package are proving to be of
assistance here, since it has already solved many of the domain's problems.
The different nature of its client/server interaction model, however, enforces a
somewhat cumbersome interface which we do not need to suffer in the Textual
environment. This simplifies more sophisticated interactions such as
changing the list of available values in a Select widget in response to
a change in a particular option.

Astute readers will notice there is absolutely no styling on the form
components. As a result the proof-of-concept form looks pretty ropey in a
window of non-optimal size.
